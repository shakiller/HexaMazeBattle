<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–ì–µ–∫—Å–æ–ª–∞–±–∏—Ä–∏–Ω—Ç</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0e17;
  --panel-bg: rgba(15, 23, 42, 0.95);
  --hex-size: 55px;
  --hex-gap: 0px;
  --hex-color: #1e293b;
  --hex-border: #0ea5e9;
  --path-color: #facc15;
  --path-glow: rgba(250, 204, 21, 0.6);
  --start-color: #22c55e;
  --finish-color: #ef4444;
  --player1-color: #3b82f6;
  --player2-color: #ec4899;
  --text: #e2e8f0;
  --accent: #0ea5e9;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  background: var(--bg);
  background-image:
    radial-gradient(ellipse at 20% 80%, rgba(14, 165, 233, 0.1) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 20%, rgba(168, 85, 247, 0.1) 0%, transparent 50%);
  font-family: 'Orbitron', sans-serif;
  color: var(--text);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px;
  overflow-x: hidden;
}

h1 {
  font-size: 1.3em;
  margin: 8px 0;
  background: linear-gradient(90deg, #0ea5e9, #a855f7, #facc15);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  text-align: center;
  letter-spacing: 2px;
}

.game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  width: 100%;
  max-width: 900px;
}

.game-mode-panel {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: center;
}

.mode-btn {
  padding: 8px 14px;
  background: var(--panel-bg);
  border: 1px solid rgba(14, 165, 233, 0.4);
  border-radius: 8px;
  color: var(--text);
  font-family: inherit;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.3s;
}

.mode-btn:hover { border-color: var(--accent); background: rgba(14, 165, 233, 0.2); }
.mode-btn.active { background: rgba(14, 165, 233, 0.3); border-color: var(--accent); }

.top-panel {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  justify-content: center;
  align-items: stretch;
  background: var(--panel-bg);
  padding: 12px 15px;
  border-radius: 12px;
  border: 1px solid rgba(14, 165, 233, 0.3);
  width: 100%;
}

.player-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
  padding: 8px 12px;
  border-radius: 8px;
  transition: all 0.3s;
  min-width: 80px;
}

.player-section.active.player1 {
  background: rgba(59, 130, 246, 0.3);
  box-shadow: 0 0 25px rgba(59, 130, 246, 0.6);
  border: 2px solid var(--player1-color);
  border-radius: 12px;
}

.player-section.active.player2 {
  background: rgba(236, 72, 153, 0.3);
  box-shadow: 0 0 25px rgba(236, 72, 153, 0.6);
  border: 2px solid var(--player2-color);
  border-radius: 12px;
}

.player-token-preview {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  border: 3px solid white;
}

.player1 .player-token-preview { background: var(--player1-color); }
.player2 .player-token-preview { background: var(--player2-color); }

.player-label { font-size: 11px; }

.dice-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
}

.dice {
  width: 55px;
  height: 55px;
  background: linear-gradient(135deg, #1e293b, #334155);
  border: 2px solid var(--accent);
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 26px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.dice:hover:not(.rolling):not(.disabled) {
  transform: scale(1.1);
  box-shadow: 0 0 20px var(--accent);
}

.dice.disabled { opacity: 0.5; cursor: not-allowed; }
.dice.rolling { animation: diceRoll 0.5s ease-in-out; }

@keyframes diceRoll {
  0%, 100% { transform: rotate(0deg) scale(1); }
  25% { transform: rotate(-15deg) scale(1.1); }
  50% { transform: rotate(15deg) scale(1.15); }
  75% { transform: rotate(-10deg) scale(1.1); }
}

.roll-btn {
  padding: 6px 14px;
  background: linear-gradient(135deg, var(--accent), #6366f1);
  border: none;
  border-radius: 6px;
  color: white;
  font-family: inherit;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.3s;
}

.roll-btn:hover:not(:disabled) { transform: scale(1.05); }
.roll-btn:disabled { opacity: 0.5; cursor: not-allowed; }

.points-display {
  background: rgba(250, 204, 21, 0.2);
  border: 2px solid var(--path-color);
  border-radius: 10px;
  padding: 10px 15px;
  text-align: center;
  min-width: 100px;
}

.points-value {
  font-size: 28px;
  font-weight: bold;
  color: var(--path-color);
  text-shadow: 0 0 10px var(--path-glow);
}

.points-label { font-size: 10px; color: #94a3b8; }

.tile-preview-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  padding: 8px;
  background: rgba(30, 41, 59, 0.5);
  border-radius: 10px;
  border: 1px solid rgba(14, 165, 233, 0.3);
}

.tile-preview-label { font-size: 10px; color: #94a3b8; }

.tile-preview-container {
  display: flex;
  align-items: center;
  gap: 8px;
}

.tile-preview {
  width: 60px;
  height: 70px;
  transition: transform 0.3s;
}

.tile-preview svg {
  width: 100%;
  height: 100%;
  filter: drop-shadow(0 0 8px var(--path-glow));
}

.rotate-buttons {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.rotate-btn {
  width: 28px;
  height: 28px;
  background: rgba(30, 41, 59, 0.8);
  border: 1px solid var(--accent);
  border-radius: 6px;
  color: var(--text);
  font-size: 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.rotate-btn:hover {
  background: rgba(14, 165, 233, 0.3);
  transform: scale(1.1);
}

.action-panel {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  padding: 10px;
  background: var(--panel-bg);
  border-radius: 10px;
  border: 1px solid rgba(14, 165, 233, 0.2);
  width: 100%;
}

.action-btn {
  padding: 10px 16px;
  background: rgba(30, 41, 59, 0.8);
  border: 1px solid rgba(14, 165, 233, 0.4);
  border-radius: 8px;
  color: var(--text);
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.3s;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 3px;
}

.action-btn:hover:not(:disabled) {
  background: rgba(14, 165, 233, 0.3);
  border-color: var(--accent);
  transform: translateY(-2px);
}

.action-btn:disabled { opacity: 0.4; cursor: not-allowed; }

.action-btn.selected {
  background: rgba(14, 165, 233, 0.4);
  border-color: var(--accent);
  box-shadow: 0 0 15px rgba(14, 165, 233, 0.5);
}

.action-cost {
  font-size: 10px;
  color: var(--path-color);
  background: rgba(250, 204, 21, 0.2);
  padding: 2px 6px;
  border-radius: 4px;
}

.status-bar {
  text-align: center;
  padding: 8px 15px;
  font-size: 12px;
  background: var(--panel-bg);
  border-radius: 8px;
  min-height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.status-bar.highlight {
  color: var(--accent);
  text-shadow: 0 0 10px var(--accent);
}

.board-wrapper {
  overflow: auto;
  max-width: 100%;
  padding: 10px;
}

.board {
  display: inline-block;
  position: relative;
}

.hex-cell {
  position: absolute;
  width: var(--hex-size);
  height: calc(var(--hex-size) * 1.1547);
  cursor: pointer;
  transition: transform 0.2s, filter 0.2s;
}

.hex-cell svg {
  width: 100%;
  height: 100%;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
}

.hex-cell:hover {
  transform: scale(1.1);
  z-index: 10;
}

.hex-cell.empty-cell {
  cursor: pointer;
}

.hex-cell.empty-cell:hover {
  filter: drop-shadow(0 0 12px #22c55e);
}

.hex-cell.valid-target {
  animation: validPulse 1s infinite;
}

@keyframes validPulse {
  0%, 100% { filter: drop-shadow(0 0 8px #22c55e); }
  50% { filter: drop-shadow(0 0 20px #22c55e); }
}

.hex-cell.selected-cell {
  filter: drop-shadow(0 0 15px #facc15);
}

.player-token {
  position: absolute;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: 3px solid white;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 20;
  transition: all 0.4s ease;
}

.player-token.p1 {
  background: var(--player1-color);
  box-shadow: 0 0 15px var(--player1-color), 0 0 30px var(--player1-color);
}
.player-token.p2 {
  background: var(--player2-color);
  margin-left: 8px;
  box-shadow: 0 0 15px var(--player2-color), 0 0 30px var(--player2-color);
}

.player-token.current-turn {
  animation: tokenPulse 1.5s infinite;
}

@keyframes tokenPulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-50%, -50%) scale(1.2); }
}

.player-token.has-flag::after {
  content: 'üö©';
  position: absolute;
  top: -18px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 14px;
}

.legend {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  justify-content: center;
  font-size: 10px;
  color: #64748b;
  padding: 8px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 4px;
}

.legend-color {
  width: 12px;
  height: 12px;
  border-radius: 3px;
}

.rules-panel {
  background: var(--panel-bg);
  padding: 12px 15px;
  border-radius: 10px;
  border: 1px solid rgba(14, 165, 233, 0.2);
  font-size: 11px;
  width: 100%;
}

.rules-panel h3 {
  margin-bottom: 8px;
  color: var(--accent);
  font-size: 12px;
}

.rules-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 8px;
  color: #94a3b8;
}

.rule-item {
  display: flex;
  align-items: center;
  gap: 8px;
}

.rule-cost {
  background: rgba(250, 204, 21, 0.2);
  color: var(--path-color);
  padding: 2px 8px;
  border-radius: 4px;
  font-weight: bold;
  min-width: 35px;
  text-align: center;
}

.settings-panel {
  background: var(--panel-bg);
  padding: 15px 20px;
  border-radius: 12px;
  border: 1px solid rgba(14, 165, 233, 0.3);
  margin-top: 10px;
  width: 100%;
  display: none;
}

.setting-row {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
  gap: 10px;
}

.setting-row label {
  min-width: 180px;
  font-size: 12px;
  color: #94a3b8;
}

.setting-row input[type="range"] {
  flex: 1;
  min-width: 150px;
  height: 6px;
  background: #1e293b;
  border-radius: 3px;
  outline: none;
}

.setting-row span {
  min-width: 30px;
  text-align: center;
  font-size: 12px;
  color: var(--text);
}

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
}

.modal-overlay.show {
  opacity: 1;
  pointer-events: auto;
}

.modal {
  background: var(--panel-bg);
  padding: 25px 35px;
  border-radius: 16px;
  border: 2px solid var(--accent);
  text-align: center;
  max-width: 90%;
  animation: modalPop 0.3s ease;
}

@keyframes modalPop {
  from { transform: scale(0.8); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

.modal h2 {
  font-size: 1.4em;
  margin-bottom: 12px;
  background: linear-gradient(90deg, #22c55e, #facc15);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}

.modal p { margin-bottom: 18px; color: #94a3b8; }

.modal-buttons { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }

.modal-btn {
  padding: 10px 25px;
  background: linear-gradient(135deg, var(--accent), #6366f1);
  border: none;
  border-radius: 8px;
  color: white;
  font-family: inherit;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.3s;
}

.modal-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px var(--accent); }

.modal-btn.secondary {
  background: rgba(30, 41, 59, 0.8);
  border: 1px solid var(--accent);
}

@media (max-width: 600px) {
  :root { --hex-size: 42px; }
  h1 { font-size: 1.1em; }
  .top-panel { padding: 10px; gap: 10px; }
  .dice { width: 45px; height: 45px; font-size: 20px; }
  .action-btn { padding: 8px 12px; font-size: 11px; }
  .points-value { font-size: 22px; }
  .setting-row { flex-wrap: wrap; }
  .setting-row label { min-width: 140px; }
}
</style>
</head>
<body>

<h1>üî∑ –ì–ï–ö–°–û–õ–ê–ë–ò–†–ò–ù–¢ üî∑</h1>

<div class="game-container">
  <div class="game-mode-panel">
    <button class="mode-btn active" data-mode="simple" onclick="setGameMode('simple')">–î–æ —Ñ–∏–Ω–∏—à–∞</button>
    <button class="mode-btn" data-mode="flag" onclick="setGameMode('flag')">–° —Ñ–ª–∞–≥–æ–º ‚Ü©</button>
    <button class="mode-btn active" data-players="1" onclick="setPlayers(1)">1 –∏–≥—Ä–æ–∫</button>
    <button class="mode-btn" data-players="2" onclick="setPlayers(2)">2 –∏–≥—Ä–æ–∫–∞</button>
    <button class="mode-btn" onclick="restartGame()">üîÑ –ó–∞–Ω–æ–≤–æ</button>
    <button class="mode-btn" onclick="toggleSettings()">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
  </div>

  <div class="settings-panel" id="settings-panel">
    <div class="setting-row">
      <label>–®–∏—Ä–∏–Ω–∞ –ø–æ–ª—è:</label>
      <input type="range" id="cols-slider" min="5" max="15" value="7" oninput="updateSettingDisplay()">
      <span id="cols-value">7</span>
    </div>
    <div class="setting-row">
      <label>–í—ã—Å–æ—Ç–∞ –ø–æ–ª—è:</label>
      <input type="range" id="rows-slider" min="5" max="15" value="7" oninput="updateSettingDisplay()">
      <span id="rows-value">7</span>
    </div>
    <div class="setting-row">
      <label>–û—Ç—Å—Ç—É–ø –º–µ–∂–¥—É —è—á–µ–π–∫–∞–º–∏:</label>
      <input type="range" id="gap-slider" min="-10" max="20" value="0" oninput="updateSettingDisplay()">
      <span id="gap-value">0</span>px
    </div>
    <div class="setting-row">
      <label>–†–∞–∑–º–µ—Ä —è—á–µ–π–∫–∏:</label>
      <input type="range" id="size-slider" min="30" max="100" value="55" oninput="updateSettingDisplay()">
      <span id="size-value">55</span>px
    </div>
    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
      <button class="mode-btn" onclick="applySettings()">‚úì –ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
      <button class="mode-btn" onclick="resetSettings()">‚Ü∫ –°–±—Ä–æ—Å–∏—Ç—å</button>
    </div>
  </div>

  <div class="top-panel">
    <div class="player-section player1 active" id="player1-section">
      <div class="player-token-preview"></div>
      <span class="player-label">–ò–≥—Ä–æ–∫ 1</span>
    </div>

    <div class="dice-section">
      <div class="dice" id="dice" onclick="rollDice()">?</div>
      <button class="roll-btn" id="roll-btn" onclick="rollDice()">üé≤ –ë—Ä–æ—Å–∏—Ç—å</button>
    </div>

    <div class="points-display">
      <div class="points-value" id="points-value">0</div>
      <div class="points-label">–û–ß–ö–ò</div>
    </div>

    <div class="player-section player2" id="player2-section" style="display: none;">
      <div class="player-token-preview"></div>
      <span class="player-label">–ò–≥—Ä–æ–∫ 2</span>
    </div>

    <div class="tile-preview-section">
      <span class="tile-preview-label">–ù–æ–≤—ã–π —Ç–∞–π–ª</span>
      <div class="tile-preview-container">
        <button class="rotate-btn" onclick="rotateNextTile(-1)">‚Ü∂</button>
        <div class="tile-preview" id="next-tile"></div>
        <button class="rotate-btn" onclick="rotateNextTile(1)">‚Ü∑</button>
      </div>
    </div>
  </div>

  <div class="action-panel" id="action-panel">
    <button class="action-btn" id="btn-move" onclick="selectAction('move')" disabled>
      ‚û°Ô∏è –î–≤–∏–≥–∞—Ç—å—Å—è
      <span class="action-cost">1 –æ—á–∫–æ/—à–∞–≥</span>
    </button>
    <button class="action-btn" id="btn-place-adj" onclick="selectAction('placeAdjacent')" disabled>
      üß© –¢–∞–π–ª —Ä—è–¥–æ–º
      <span class="action-cost">2 –æ—á–∫–∞</span>
    </button>
    <button class="action-btn" id="btn-place-any" onclick="selectAction('placeAnywhere')" disabled>
      üó∫Ô∏è –¢–∞–π–ª –∫—É–¥–∞ —É–≥–æ–¥–Ω–æ
      <span class="action-cost">4 –æ—á–∫–∞</span>
    </button>
    <button class="action-btn" id="btn-replace-adj" onclick="selectAction('replaceAdjacent')" disabled>
      üîÑ –ò–∑–º–µ–Ω–∏—Ç—å —Ä—è–¥–æ–º
      <span class="action-cost">5 –æ—á–∫–æ–≤</span>
    </button>
    <button class="action-btn" id="btn-replace" onclick="selectAction('replace')" disabled>
      üîÑ –ò–∑–º–µ–Ω–∏—Ç—å –ª—é–±–æ–π
      <span class="action-cost">6 –æ—á–∫–æ–≤</span>
    </button>
    <button class="action-btn" id="btn-end" onclick="endTurn()" disabled>
      ‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ö–æ–¥
    </button>
  </div>

  <div class="status-bar" id="status">–ù–∞–∂–º–∏—Ç–µ "–ë—Ä–æ—Å–∏—Ç—å" —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ö–æ–¥</div>

  <div class="board-wrapper">
    <div class="board" id="board"></div>
  </div>

  <div class="legend">
    <div class="legend-item"><div class="legend-color" style="background: var(--start-color)"></div> –°—Ç–∞—Ä—Ç</div>
    <div class="legend-item"><div class="legend-color" style="background: var(--finish-color)"></div> –§–∏–Ω–∏—à</div>
    <div class="legend-item"><div class="legend-color" style="background: var(--path-color)"></div> –ü—É—Ç—å</div>
    <div class="legend-item"><div class="legend-color" style="background: var(--player1-color)"></div> –ò–≥—Ä–æ–∫ 1</div>
    <div class="legend-item"><div class="legend-color" style="background: var(--player2-color)"></div> –ò–≥—Ä–æ–∫ 2</div>
  </div>

  <div class="rules-panel">
    <h3>üìú –°—Ç–æ–∏–º–æ—Å—Ç—å –¥–µ–π—Å—Ç–≤–∏–π (—Ç—Ä–∞—Ç—å—Ç–µ –æ—á–∫–∏ –∫–∞–∫ —Ö–æ—Ç–∏—Ç–µ)</h3>
    <div class="rules-grid">
      <div class="rule-item"><span class="rule-cost">1</span> –î–≤–∏–∂–µ–Ω–∏–µ –Ω–∞ 1 –∫–ª–µ—Ç–∫—É</div>
      <div class="rule-item"><span class="rule-cost">2</span> –¢–∞–π–ª —Ä—è–¥–æ–º —Å —Ñ–∏—à–∫–æ–π</div>
      <div class="rule-item"><span class="rule-cost">4</span> –¢–∞–π–ª –Ω–∞ –ª—é–±–æ–µ –º–µ—Å—Ç–æ</div>
      <div class="rule-item"><span class="rule-cost">5</span> –ò–∑–º–µ–Ω–∏—Ç—å —Å–æ—Å–µ–¥–Ω–∏–π —Ç–∞–π–ª</div>
      <div class="rule-item"><span class="rule-cost">6</span> –ò–∑–º–µ–Ω–∏—Ç—å –ª—é–±–æ–π —Ç–∞–π–ª</div>
    </div>
  </div>
</div>

<div class="modal-overlay" id="modal">
  <div class="modal">
    <h2 id="modal-title">üéâ –ü–æ–±–µ–¥–∞!</h2>
    <p id="modal-text">–ò–≥—Ä–æ–∫ 1 –¥–æ—Å—Ç–∏–≥ —Ñ–∏–Ω–∏—à–∞!</p>
    <div class="modal-buttons">
      <button class="modal-btn" onclick="closeModal()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
    </div>
  </div>
</div>

<div class="modal-overlay" id="replace-modal">
  <div class="modal">
    <h2>–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ</h2>
    <p id="replace-modal-text">–ß—Ç–æ —Å–¥–µ–ª–∞—Ç—å —Å —ç—Ç–∏–º —Ç–∞–π–ª–æ–º?</p>
    <div class="modal-buttons">
      <button class="modal-btn" onclick="doRotateTile()">‚Üª –ü–æ–≤–µ—Ä–Ω—É—Ç—å</button>
      <button class="modal-btn" onclick="doReplaceTile()">üîÅ –ó–∞–º–µ–Ω–∏—Ç—å</button>
      <button class="modal-btn secondary" onclick="cancelReplace()">–û—Ç–º–µ–Ω–∞</button>
    </div>
  </div>
</div>

<script>
const COST = {
  move: 1,
  placeAdjacent: 2,
  placeAnywhere: 4,
  replaceAdjacent: 5,
  replace: 6
};

const state = {
  board: [],
  rows: 7,
  cols: 7,
  hexSize: 55,
  hexGap: 0,
  players: [
    { row: 0, col: 3, hasFlag: false },
    { row: 0, col: 3, hasFlag: false }
  ],
  currentPlayer: 0,
  numPlayers: 1,
  points: 0,
  gameMode: 'simple',
  phase: 'roll',
  selectedAction: null,
  selectedCell: null,
  nextTileType: 0,
  nextTileRotation: 0,
  startPos: { row: 0, col: 3 },
  finishPos: { row: 6, col: 3 }
};

// Tile types: each has edges array showing which sides have openings
// Edges: 0=top, 1=top-right, 2=bottom-right, 3=bottom, 4=bottom-left, 5=top-left
const TILE_TYPES = [
  [0, 3],       // Straight vertical
  [1, 4],       // Straight diagonal /
  [2, 5],       // Straight diagonal \
  [0, 1],       // Turn top to top-right
  [0, 2],       // Wide turn
  [1, 2],       // Turn right side
  [3, 4],       // Turn bottom
  [0, 1, 3],    // T-junction
  [0, 2, 4],    // Y-junction
];

function rotateEdges(edges, rotation) {
  const r = ((rotation % 6) + 6) % 6;
  return edges.map(edge => (edge + r) % 6);
}

// Hex grid positioning - flat-top hexagon layout with gap
function getHexPosition(row, col) {
  const size = state.hexSize;
  const gap = state.hexGap;
  const w = size;
  const h = size * 1.1547;
  const horizDist = w * 0.75 + gap;
  const vertDist = h + gap * 0.866;

  const x = col * horizDist;
  const y = row * vertDist + (col % 2 === 1 ? vertDist * 0.5 : 0);

  return { x, y };
}

// Get center point of an edge for drawing paths
function getEdgePoint(edge, radius = 42) {
  // For flat-top hex: edge 0 = top, going clockwise
  const angles = [
    -90,   // 0: top
    -30,   // 1: top-right
    30,    // 2: bottom-right
    90,    // 3: bottom
    150,   // 4: bottom-left
    210    // 5: top-left
  ];
  const angle = angles[edge] * Math.PI / 180;
  return {
    x: 50 + radius * Math.cos(angle),
    y: 57.7 + radius * Math.sin(angle)
  };
}

function createTileSVG(tileType, rotation, isStart, isFinish, isEmpty) {
  // Flat-top hexagon
  const points = [];
  for (let i = 0; i < 6; i++) {
    const angle = (Math.PI / 3) * i;
    points.push(`${50 + 46 * Math.cos(angle)},${57.7 + 46 * Math.sin(angle)}`);
  }
  const hexPoints = points.join(' ');

  let fillColor = isEmpty ? '#1a2332' : '#1e3a5f';
  let strokeColor = isEmpty ? '#334155' : '#0ea5e9';

  if (isStart) { fillColor = '#166534'; strokeColor = '#22c55e'; }
  if (isFinish) { fillColor = '#7f1d1d'; strokeColor = '#ef4444'; }

  let svg = `<svg viewBox="0 0 100 115.4" xmlns="http://www.w3.org/2000/svg">
    <polygon points="${hexPoints}" fill="${fillColor}" stroke="${strokeColor}" stroke-width="2.5"/>`;

  // Draw paths - –≤—Å–µ–≥–¥–∞ –∂—ë–ª—Ç—ã–π —Ü–≤–µ—Ç
  if (!isEmpty && tileType !== null) {
    const edges = rotateEdges(TILE_TYPES[tileType], rotation);
    const cx = 50, cy = 57.7;

    // Draw path shadow
    edges.forEach(edge => {
      const p = getEdgePoint(edge, 48);
      svg += `<line x1="${cx}" y1="${cy}" x2="${p.x}" y2="${p.y}"
              stroke="#1a1a2e" stroke-width="18" stroke-linecap="round"/>`;
    });

    // Draw path main - —è—Ä–∫–∏–π –∂—ë–ª—Ç—ã–π
    edges.forEach(edge => {
      const p = getEdgePoint(edge, 48);
      svg += `<line x1="${cx}" y1="${cy}" x2="${p.x}" y2="${p.y}"
              stroke="#fbbf24" stroke-width="14" stroke-linecap="round"/>`;
    });

    // Center hub
    svg += `<circle cx="${cx}" cy="${cy}" r="10" fill="#fbbf24"/>`;
    svg += `<circle cx="${cx}" cy="${cy}" r="5" fill="#fef3c7"/>`;
  }

  // Start/Finish labels
  if (isStart) {
    svg += `<text x="50" y="62" text-anchor="middle" fill="white" font-size="10" font-weight="bold" font-family="sans-serif">–°–¢–ê–†–¢</text>`;
  }
  if (isFinish) {
    svg += `<text x="50" y="55" text-anchor="middle" fill="white" font-size="10" font-weight="bold" font-family="sans-serif">–§–ò–ù–ò–®</text>`;
    if (state.gameMode === 'flag') {
      svg += `<text x="50" y="78" text-anchor="middle" font-size="16">üö©</text>`;
    }
  }

  svg += '</svg>';
  return svg;
}

function initBoard() {
  // Update start and finish positions based on board size
  state.startPos = { row: 0, col: Math.floor(state.cols / 2) };
  state.finishPos = { row: state.rows - 1, col: Math.floor(state.cols / 2) };
  
  // Update CSS variables
  document.documentElement.style.setProperty('--hex-size', state.hexSize + 'px');
  document.documentElement.style.setProperty('--hex-gap', state.hexGap + 'px');

  state.board = [];
  for (let r = 0; r < state.rows; r++) {
    const row = [];
    for (let c = 0; c < state.cols; c++) {
      const isStart = r === state.startPos.row && c === state.startPos.col;
      const isFinish = r === state.finishPos.row && c === state.finishPos.col;

      row.push({
        tileType: (isStart || isFinish) ? 0 : null,
        rotation: 0,
        isEmpty: !(isStart || isFinish),
        isStart,
        isFinish
      });
    }
    state.board.push(row);
  }

  state.players = [
    { row: state.startPos.row, col: state.startPos.col, hasFlag: false },
    { row: state.startPos.row, col: state.startPos.col, hasFlag: false }
  ];

  state.nextTileType = Math.floor(Math.random() * TILE_TYPES.length);
  state.nextTileRotation = 0;
  state.currentPlayer = 0;
  state.phase = 'roll';
  state.points = 0;
  state.selectedAction = null;
  state.selectedCell = null;

  renderBoard();
  renderNextTile();
  updateUI();
  updateStatus('–ë—Ä–æ—Å—å—Ç–µ –∫—É–±–∏–∫, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –æ—á–∫–∏!');
}

function renderBoard() {
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';

  // Calculate board size with gaps
  let maxX = 0, maxY = 0;
  for (let r = 0; r < state.rows; r++) {
    for (let c = 0; c < state.cols; c++) {
      const pos = getHexPosition(r, c);
      maxX = Math.max(maxX, pos.x + state.hexSize + 10);
      maxY = Math.max(maxY, pos.y + state.hexSize * 1.1547 + 10);
    }
  }
  boardEl.style.width = maxX + 'px';
  boardEl.style.height = maxY + 'px';

  for (let r = 0; r < state.rows; r++) {
    for (let c = 0; c < state.cols; c++) {
      const cell = state.board[r][c];
      const pos = getHexPosition(r, c);

      const cellEl = document.createElement('div');
      cellEl.className = 'hex-cell';
      cellEl.style.left = pos.x + 'px';
      cellEl.style.top = pos.y + 'px';
      cellEl.dataset.row = r;
      cellEl.dataset.col = c;

      cellEl.innerHTML = createTileSVG(
        cell.tileType,
        cell.rotation,
        cell.isStart,
        cell.isFinish,
        cell.isEmpty
      );

      if (cell.isEmpty) {
        cellEl.classList.add('empty-cell');
      }

      cellEl.addEventListener('click', () => handleCellClick(r, c));

      // Add player tokens
      for (let p = 0; p < state.numPlayers; p++) {
        if (state.players[p].row === r && state.players[p].col === c) {
          const token = document.createElement('div');
          token.className = `player-token p${p + 1}`;
          if (state.players[p].hasFlag) token.classList.add('has-flag');
          if (p === state.currentPlayer) token.classList.add('current-turn');
          cellEl.appendChild(token);
        }
      }

      boardEl.appendChild(cellEl);
    }
  }
}

function renderNextTile() {
  const el = document.getElementById('next-tile');
  el.innerHTML = createTileSVG(state.nextTileType, state.nextTileRotation, false, false, false);
}

function rotateNextTile(dir) {
  state.nextTileRotation = ((state.nextTileRotation + dir) % 6 + 6) % 6;
  renderNextTile();
}

function rollDice() {
  if (state.phase !== 'roll') return;

  const diceEl = document.getElementById('dice');
  diceEl.classList.add('rolling');

  let rolls = 0;
  const rollInterval = setInterval(() => {
    diceEl.textContent = Math.floor(Math.random() * 6) + 1;
    rolls++;
    if (rolls > 12) {
      clearInterval(rollInterval);
      const value = Math.floor(Math.random() * 6) + 1;
      state.points = value;
      diceEl.textContent = value;
      diceEl.classList.remove('rolling');

      state.phase = 'action';
      updateUI();
      updateStatus(`–í—ã–ø–∞–ª–æ ${value}! –ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –ø—É—Å—Ç—É—é –∫–ª–µ—Ç–∫—É —á—Ç–æ–±—ã —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å —Ç–∞–π–ª, –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ.`);
    }
  }, 50);
}

function updateUI() {
  document.getElementById('points-value').textContent = state.points;

  const diceEl = document.getElementById('dice');
  const rollBtn = document.getElementById('roll-btn');

  if (state.phase === 'roll') {
    diceEl.classList.remove('disabled');
    rollBtn.disabled = false;
  } else {
    diceEl.classList.add('disabled');
    rollBtn.disabled = true;
  }

  // Update action buttons
  const player = state.players[state.currentPlayer];

  document.getElementById('btn-move').disabled =
    state.phase !== 'action' || state.points < COST.move || !canMoveAnywhere(player);

  document.getElementById('btn-place-adj').disabled =
    state.phase !== 'action' || state.points < COST.placeAdjacent || !hasAdjacentEmpty(player);

  document.getElementById('btn-place-any').disabled =
    state.phase !== 'action' || state.points < COST.placeAnywhere || !hasAnyEmpty();

  document.getElementById('btn-replace-adj').disabled =
    state.phase !== 'action' || state.points < COST.replaceAdjacent || !hasAdjacentReplaceable();

  document.getElementById('btn-replace').disabled =
    state.phase !== 'action' || state.points < COST.replace || !hasReplaceable();

  document.getElementById('btn-end').disabled = state.phase !== 'action';

  // Player sections
  document.getElementById('player1-section').classList.toggle('active', state.currentPlayer === 0);
  document.getElementById('player2-section').classList.toggle('active', state.currentPlayer === 1);
  document.getElementById('player2-section').style.display = state.numPlayers > 1 ? 'flex' : 'none';

  // Highlight selected action
  document.querySelectorAll('.action-btn').forEach(btn => btn.classList.remove('selected'));
  if (state.selectedAction) {
    const btnId = {
      'move': 'btn-move',
      'placeAdjacent': 'btn-place-adj',
      'placeAnywhere': 'btn-place-any',
      'replaceAdjacent': 'btn-replace-adj',
      'replace': 'btn-replace'
    }[state.selectedAction];
    if (btnId) document.getElementById(btnId).classList.add('selected');
  }
}

function getNeighbors(row, col) {
  const neighbors = [];
  const isOddCol = col % 2 === 1;

  // Flat-top hex neighbors - column offset layout
  // Edge 0=top, 1=top-right, 2=bottom-right, 3=bottom, 4=bottom-left, 5=top-left
  const offsets = isOddCol ? [
    { dr: -1, dc: 0, edge: 0 },  // top
    { dr: 0, dc: 1, edge: 1 },   // top-right
    { dr: 1, dc: 1, edge: 2 },   // bottom-right
    { dr: 1, dc: 0, edge: 3 },   // bottom
    { dr: 1, dc: -1, edge: 4 },  // bottom-left
    { dr: 0, dc: -1, edge: 5 },  // top-left
  ] : [
    { dr: -1, dc: 0, edge: 0 },  // top
    { dr: -1, dc: 1, edge: 1 }, // top-right
    { dr: 0, dc: 1, edge: 2 },   // bottom-right
    { dr: 1, dc: 0, edge: 3 },   // bottom
    { dr: 0, dc: -1, edge: 4 },  // bottom-left
    { dr: -1, dc: -1, edge: 5 }, // top-left
  ];

  offsets.forEach(({ dr, dc, edge }) => {
    const nr = row + dr;
    const nc = col + dc;
    if (nr >= 0 && nr < state.rows && nc >= 0 && nc < state.cols) {
      neighbors.push({ row: nr, col: nc, edge });
    }
  });

  return neighbors;
}

function hasPathToEdge(cell, edge) {
  if (cell.isStart || cell.isFinish) return true; // Start/finish connect to all edges
  if (cell.isEmpty || cell.tileType === null) return false;

  const edges = rotateEdges(TILE_TYPES[cell.tileType], cell.rotation);
  return edges.includes(edge);
}

function canMoveAnywhere(player) {
  const cell = state.board[player.row][player.col];
  const neighbors = getNeighbors(player.row, player.col);

  return neighbors.some(n => {
    const nCell = state.board[n.row][n.col];
    if (nCell.isEmpty) return false;

    const myEdge = n.edge;
    const theirEdge = (myEdge + 3) % 6;

    return hasPathToEdge(cell, myEdge) && hasPathToEdge(nCell, theirEdge);
  });
}

function getValidMoves(player) {
  const cell = state.board[player.row][player.col];
  const neighbors = getNeighbors(player.row, player.col);
  const valid = [];

  neighbors.forEach(n => {
    const nCell = state.board[n.row][n.col];
    if (nCell.isEmpty) return;

    const myEdge = n.edge;
    const theirEdge = (myEdge + 3) % 6;

    if (hasPathToEdge(cell, myEdge) && hasPathToEdge(nCell, theirEdge)) {
      valid.push({ row: n.row, col: n.col });
    }
  });

  return valid;
}

function hasAdjacentEmpty(player) {
  const neighbors = getNeighbors(player.row, player.col);
  return neighbors.some(n => state.board[n.row][n.col].isEmpty);
}

function getAdjacentEmpty(player) {
  const neighbors = getNeighbors(player.row, player.col);
  return neighbors.filter(n => state.board[n.row][n.col].isEmpty);
}

function hasAnyEmpty() {
  for (let r = 0; r < state.rows; r++) {
    for (let c = 0; c < state.cols; c++) {
      if (state.board[r][c].isEmpty) return true;
    }
  }
  return false;
}

function getAllEmpty() {
  const empty = [];
  for (let r = 0; r < state.rows; r++) {
    for (let c = 0; c < state.cols; c++) {
      if (state.board[r][c].isEmpty) empty.push({ row: r, col: c });
    }
  }
  return empty;
}

function hasReplaceable() {
  for (let r = 0; r < state.rows; r++) {
    for (let c = 0; c < state.cols; c++) {
      const cell = state.board[r][c];
      if (!cell.isEmpty && !cell.isStart && !cell.isFinish) return true;
    }
  }
  return false;
}

function getReplaceable() {
  const tiles = [];
  for (let r = 0; r < state.rows; r++) {
    for (let c = 0; c < state.cols; c++) {
      const cell = state.board[r][c];
      if (!cell.isEmpty && !cell.isStart && !cell.isFinish) {
        tiles.push({ row: r, col: c });
      }
    }
  }
  return tiles;
}

function hasAdjacentReplaceable() {
  const player = state.players[state.currentPlayer];
  const neighbors = getNeighbors(player.row, player.col);
  return neighbors.some(n => {
    const cell = state.board[n.row][n.col];
    return !cell.isEmpty && !cell.isStart && !cell.isFinish;
  });
}

function getAdjacentReplaceable() {
  const player = state.players[state.currentPlayer];
  const neighbors = getNeighbors(player.row, player.col);
  return neighbors.filter(n => {
    const cell = state.board[n.row][n.col];
    return !cell.isEmpty && !cell.isStart && !cell.isFinish;
  });
}

function selectAction(action) {
  state.selectedAction = action;
  state.selectedCell = null;
  clearHighlights();

  const player = state.players[state.currentPlayer];
  let targets = [];

  switch (action) {
    case 'move':
      targets = getValidMoves(player);
      updateStatus('–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–µ—Ç–∫—É –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è (1 –æ—á–∫–æ)');
      break;
    case 'placeAdjacent':
      targets = getAdjacentEmpty(player);
      updateStatus('–í—ã–±–µ—Ä–∏—Ç–µ –ø—É—Å—Ç—É—é –∫–ª–µ—Ç–∫—É —Ä—è–¥–æ–º —Å —Ñ–∏—à–∫–æ–π (2 –æ—á–∫–∞)');
      break;
    case 'placeAnywhere':
      targets = getAllEmpty();
      updateStatus('–í—ã–±–µ—Ä–∏—Ç–µ –ª—é–±—É—é –ø—É—Å—Ç—É—é –∫–ª–µ—Ç–∫—É (4 –æ—á–∫–∞)');
      break;
    case 'replaceAdjacent':
      targets = getAdjacentReplaceable();
      updateStatus('–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Å–µ–¥–Ω–∏–π —Ç–∞–π–ª –¥–ª—è –∑–∞–º–µ–Ω—ã/–ø–æ–≤–æ—Ä–æ—Ç–∞ (5 –æ—á–∫–æ–≤)');
      break;
    case 'replace':
      targets = getReplaceable();
      updateStatus('–í—ã–±–µ—Ä–∏—Ç–µ –ª—é–±–æ–π —Ç–∞–π–ª –¥–ª—è –∑–∞–º–µ–Ω—ã/–ø–æ–≤–æ—Ä–æ—Ç–∞ (6 –æ—á–∫–æ–≤)');
      break;
  }

  highlightCells(targets);
  updateUI();
}

function highlightCells(cells) {
  cells.forEach(cell => {
    const el = document.querySelector(`.hex-cell[data-row="${cell.row}"][data-col="${cell.col}"]`);
    if (el) el.classList.add('valid-target');
  });
}

function clearHighlights() {
  document.querySelectorAll('.hex-cell').forEach(el => {
    el.classList.remove('valid-target', 'selected-cell');
  });
}

function handleCellClick(row, col) {
  if (state.phase !== 'action') {
    updateStatus('–°–Ω–∞—á–∞–ª–∞ –±—Ä–æ—Å—å—Ç–µ –∫—É–±–∏–∫!');
    return;
  }

  const player = state.players[state.currentPlayer];
  const cell = state.board[row][col];

  // Auto-select action based on clicked cell
  if (!state.selectedAction) {
    // Empty cell - try to place tile
    if (cell.isEmpty) {
      const isAdjacent = getAdjacentEmpty(player).some(c => c.row === row && c.col === col);

      if (isAdjacent && state.points >= COST.placeAdjacent) {
        state.selectedAction = 'placeAdjacent';
      } else if (state.points >= COST.placeAnywhere) {
        state.selectedAction = 'placeAnywhere';
      } else {
        updateStatus(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ—á–∫–æ–≤! –ù—É–∂–Ω–æ ${isAdjacent ? 2 : 4}, –µ—Å—Ç—å ${state.points}`);
        return;
      }
    }
    // Non-empty cell - try to move or replace
    else if (!cell.isStart && !cell.isFinish && state.points >= COST.replace) {
      // Check if it's a valid move target
      const validMoves = getValidMoves(player);
      if (validMoves.some(c => c.row === row && c.col === col)) {
        state.selectedAction = 'move';
      } else {
        state.selectedAction = 'replace';
      }
    }
    // Try to move
    else {
      const validMoves = getValidMoves(player);
      if (validMoves.some(c => c.row === row && c.col === col) && state.points >= COST.move) {
        state.selectedAction = 'move';
      } else {
        updateStatus('–ù–µ–ª—å–∑—è —Å—é–¥–∞ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å—Å—è –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ—á–∫–æ–≤');
        return;
      }
    }
    updateUI();
  }

  // Validate the action is possible on this cell
  switch (state.selectedAction) {
    case 'move':
      // Check valid move
      const validMoves2 = getValidMoves(player);
      if (!validMoves2.some(c => c.row === row && c.col === col)) {
        updateStatus('–ù–µ–ª—å–∑—è —Å—é–¥–∞ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å—Å—è - –Ω–µ—Ç —Å–æ–µ–¥–∏–Ω—ë–Ω–Ω–æ–≥–æ –ø—É—Ç–∏');
        state.selectedAction = null;
        return;
      }
      // Move player
      player.row = row;
      player.col = col;
      state.points -= COST.move;

      // Check flag pickup
      if (cell.isFinish && state.gameMode === 'flag' && !player.hasFlag) {
        player.hasFlag = true;
        updateStatus('üö© –§–ª–∞–≥ –ø–æ–¥–æ–±—Ä–∞–Ω! –í–æ–∑–≤—Ä–∞—â–∞–π—Ç–µ—Å—å –Ω–∞ —Å—Ç–∞—Ä—Ç!');
      }

      // Check win
      if (checkWin(player, cell)) {
        renderBoard();
        showWinModal();
        return;
      }

      renderBoard();
      state.selectedAction = null;
      clearHighlights();
      updateUI();

      if (state.points > 0 && canMoveAnywhere(player)) {
        updateStatus(`–û—Å—Ç–∞–ª–æ—Å—å ${state.points} –æ—á–∫–æ–≤. –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –∏–ª–∏ –∑–∞–≤–µ—Ä—à–∏—Ç–µ —Ö–æ–¥.`);
      } else if (state.points > 0) {
        updateStatus(`–û—Å—Ç–∞–ª–æ—Å—å ${state.points} –æ—á–∫–æ–≤.`);
      } else {
        endTurn();
      }
      break;

    case 'placeAdjacent':
      if (!cell.isEmpty) {
        updateStatus('–≠—Ç–∞ –∫–ª–µ—Ç–∫–∞ —É–∂–µ –∑–∞–Ω—è—Ç–∞!');
        state.selectedAction = null;
        return;
      }
      // Place tile
      state.board[row][col] = {
        tileType: state.nextTileType,
        rotation: state.nextTileRotation,
        isEmpty: false,
        isStart: false,
        isFinish: false
      };

      state.points -= COST.placeAdjacent;
      state.nextTileType = Math.floor(Math.random() * TILE_TYPES.length);
      state.nextTileRotation = 0;

      renderBoard();
      renderNextTile();
      state.selectedAction = null;
      clearHighlights();
      updateUI();
      updateStatus(`–¢–∞–π–ª —Ä–∞–∑–º–µ—â—ë–Ω! –û—Å—Ç–∞–ª–æ—Å—å ${state.points} –æ—á–∫–æ–≤.`);

      if (state.points <= 0) endTurn();
      break;

    case 'placeAnywhere':
      if (!cell.isEmpty) {
        updateStatus('–≠—Ç–∞ –∫–ª–µ—Ç–∫–∞ —É–∂–µ –∑–∞–Ω—è—Ç–∞!');
        state.selectedAction = null;
        return;
      }
      // Place tile
      state.board[row][col] = {
        tileType: state.nextTileType,
        rotation: state.nextTileRotation,
        isEmpty: false,
        isStart: false,
        isFinish: false
      };

      state.points -= COST.placeAnywhere;
      state.nextTileType = Math.floor(Math.random() * TILE_TYPES.length);
      state.nextTileRotation = 0;

      renderBoard();
      renderNextTile();
      state.selectedAction = null;
      clearHighlights();
      updateUI();
      updateStatus(`–¢–∞–π–ª —Ä–∞–∑–º–µ—â—ë–Ω! –û—Å—Ç–∞–ª–æ—Å—å ${state.points} –æ—á–∫–æ–≤.`);

      if (state.points <= 0) endTurn();
      break;

    case 'replaceAdjacent':
      // Check if adjacent
      if (!getAdjacentReplaceable().some(c => c.row === row && c.col === col)) {
        updateStatus('–≠—Ç–æ—Ç —Ç–∞–π–ª –Ω–µ —Ä—è–¥–æ–º —Å –≤–∞—à–µ–π —Ñ–∏—à–∫–æ–π!');
        state.selectedAction = null;
        return;
      }
      state.selectedCell = { row, col };
      state.replaceActionCost = COST.replaceAdjacent;
      document.getElementById('replace-modal').classList.add('show');
      break;

    case 'replace':
      // Show replace/rotate modal
      state.selectedCell = { row, col };
      state.replaceActionCost = COST.replace;
      document.getElementById('replace-modal').classList.add('show');
      break;
  }
}

function doRotateTile() {
  if (!state.selectedCell) return;

  const { row, col } = state.selectedCell;
  state.board[row][col].rotation = (state.board[row][col].rotation + 1) % 6;
  state.points -= state.replaceActionCost || COST.replace;

  document.getElementById('replace-modal').classList.remove('show');
  state.selectedCell = null;
  state.selectedAction = null;
  clearHighlights();
  renderBoard();
  updateUI();
  updateStatus(`–¢–∞–π–ª –ø–æ–≤—ë—Ä–Ω—É—Ç! –û—Å—Ç–∞–ª–æ—Å—å ${state.points} –æ—á–∫–æ–≤.`);

  if (state.points <= 0) endTurn();
}

function doReplaceTile() {
  if (!state.selectedCell) return;

  const { row, col } = state.selectedCell;
  state.board[row][col].tileType = state.nextTileType;
  state.board[row][col].rotation = state.nextTileRotation;
  state.points -= state.replaceActionCost || COST.replace;

  state.nextTileType = Math.floor(Math.random() * TILE_TYPES.length);
  state.nextTileRotation = 0;

  document.getElementById('replace-modal').classList.remove('show');
  state.selectedCell = null;
  state.selectedAction = null;
  clearHighlights();
  renderBoard();
  renderNextTile();
  updateUI();
  updateStatus(`–¢–∞–π–ª –∑–∞–º–µ–Ω—ë–Ω! –û—Å—Ç–∞–ª–æ—Å—å ${state.points} –æ—á–∫–æ–≤.`);

  if (state.points <= 0) endTurn();
}

function cancelReplace() {
  document.getElementById('replace-modal').classList.remove('show');
  state.selectedCell = null;
}

function checkWin(player, cell) {
  if (state.gameMode === 'simple') {
    return cell.isFinish;
  } else {
    return cell.isStart && player.hasFlag;
  }
}

function showWinModal() {
  document.getElementById('modal-title').textContent = 'üéâ –ü–æ–±–µ–¥–∞!';
  document.getElementById('modal-text').textContent =
    state.numPlayers > 1
      ? `–ò–≥—Ä–æ–∫ ${state.currentPlayer + 1} –ø–æ–±–µ–¥–∏–ª!`
      : '–í—ã –ø—Ä–æ—à–ª–∏ –ª–∞–±–∏—Ä–∏–Ω—Ç!';
  document.getElementById('modal').classList.add('show');
}

function closeModal() {
  document.getElementById('modal').classList.remove('show');
  restartGame();
}

function endTurn() {
  state.selectedAction = null;
  state.selectedCell = null;
  clearHighlights();

  state.currentPlayer = (state.currentPlayer + 1) % state.numPlayers;
  state.phase = 'roll';
  state.points = 0;

  document.getElementById('dice').textContent = '?';
  updateUI();
  updateStatus(`–ò–≥—Ä–æ–∫ ${state.currentPlayer + 1}, –±—Ä–æ—Å—å—Ç–µ –∫—É–±–∏–∫!`);
}

function updateStatus(text) {
  document.getElementById('status').textContent = text;
}

function setGameMode(mode) {
  state.gameMode = mode;
  document.querySelectorAll('.mode-btn[data-mode]').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.mode === mode);
  });
  restartGame();
}

function setPlayers(num) {
  state.numPlayers = num;
  document.querySelectorAll('.mode-btn[data-players]').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.players) === num);
  });
  restartGame();
}

function toggleSettings() {
  const panel = document.getElementById('settings-panel');
  if (panel.style.display === 'none' || panel.style.display === '') {
    panel.style.display = 'block';
    loadCurrentSettingsToPanel();
  } else {
    panel.style.display = 'none';
  }
}

function loadCurrentSettingsToPanel() {
  document.getElementById('cols-slider').value = state.cols;
  document.getElementById('rows-slider').value = state.rows;
  document.getElementById('gap-slider').value = state.hexGap;
  document.getElementById('size-slider').value = state.hexSize;
  updateSettingDisplay();
}

function updateSettingDisplay() {
  document.getElementById('cols-value').textContent = document.getElementById('cols-slider').value;
  document.getElementById('rows-value').textContent = document.getElementById('rows-slider').value;
  document.getElementById('gap-value').textContent = document.getElementById('gap-slider').value;
  document.getElementById('size-value').textContent = document.getElementById('size-slider').value;
}

function applySettings() {
  state.cols = parseInt(document.getElementById('cols-slider').value);
  state.rows = parseInt(document.getElementById('rows-slider').value);
  state.hexGap = parseInt(document.getElementById('gap-slider').value);
  state.hexSize = parseInt(document.getElementById('size-slider').value);
  
  // Hide settings panel
  document.getElementById('settings-panel').style.display = 'none';
  
  restartGame();
}

function resetSettings() {
  document.getElementById('cols-slider').value = 7;
  document.getElementById('rows-slider').value = 7;
  document.getElementById('gap-slider').value = 0;
  document.getElementById('size-slider').value = 55;
  updateSettingDisplay();
}

function restartGame() {
  initBoard();
}

// Dark mode
if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
  document.documentElement.classList.add('dark');
}
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
  document.documentElement.classList.toggle('dark', e.matches);
});

// Init
initBoard();
</script>
</body>
</html>